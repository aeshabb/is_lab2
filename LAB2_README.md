# Лабораторная работа 2: Транзакции и тестирование

## Описание реализации

### 1. Функционал импорта

#### 1.1 Импорт организаций из JSON

Реализован функционал массового добавления организаций через загрузку JSON файла:

- **Контроллер**: `ImportController` - обрабатывае## Использ## Структура проекта

```
lab2/
├── src/main/java/org/itmo/lab2/е импорта

1. Откройте браузер и перейдите на `http://localhost:8080/lab2/import`агрузку файла и вызывает сервис импорта
- **Сервис**: `ImportService` - содержит транзакционную логику импорта
- **Модель**: `ImportHistory` - хранит историю операций импорта
- **DTO**: `OrganizationImportDto` - структура данных для десериализации JSON

#### 1.2 Формат JSON файла

```json
[
  {
    "name": "Название организации",
    "coordinates": {
      "x": 100,
      "y": 200.5
    },
    "officialAddress": {
      "street": "Улица",
      "zipCode": "1234567"
    },
    "annualTurnover": 1000000,
    "employeesCount": 50,
    "rating": 4.5,
    "type": "COMMERCIAL",
    "postalAddress": {
      "street": "Улица 2",
      "zipCode": "7654321"
    }
  }
]
```

#### 1.3 Транзакционность импорта

Импорт реализован с использованием уровня изоляции **SERIALIZABLE**:

```java
@Transactional(isolation = Isolation.SERIALIZABLE, rollbackFor = Exception.class)
public ImportHistory importOrganizations(List<OrganizationImportDto> dtos, String username)
```

**Причины выбора SERIALIZABLE**:
- Гарантирует полную изоляцию при одновременном импорте несколькими пользователями
- Предотвращает фантомное чтение при проверке уникальности
- При ошибке в любой организации откатывается вся транзакция
- Ни один объект не будет создан при наличии ошибок

#### 1.4 Проверка уникальности

Реализована проверка на программном уровне с использованием **кастомных Bean Validation аннотаций**:

**Уникальное имя организации:**
```java
@UniqueOrganizationName
private String name;
```

**Уникальный zipCode адреса:**
```java
@UniqueZipCode
private String zipCode;
```

**Кастомные валидаторы:**
- `UniqueOrganizationNameValidator` - проверяет уникальность имени через репозиторий
- `UniqueZipCodeValidator` - проверяет уникальность zipCode через репозиторий

Проверки выполняются:
1. **Автоматически при валидации объекта** (через `@Valid`)
2. В рамках текущей транзакции для всех импортируемых объектов
3. Против существующих данных в БД
4. Против данных в текущем импорте (предотвращение дубликатов внутри файла)

### 2. История импорта

Реализован интерфейс для отображения истории операций импорта:

**Отображаемые поля:**
- ID операции
- Дата и время операции
- Имя пользователя, запустившего импорт
- Статус (SUCCESS/FAILED)
- Количество импортированных объектов (только для успешных)
- Сообщение об ошибке (для неуспешных)

**Доступ**: `/import`

### 3. Уровни изоляции транзакций

#### 3.1 Операции CRUD

**CREATE (создание организации)** - **REPEATABLE_READ**:
```java
@Transactional(isolation = Isolation.REPEATABLE_READ)
public Organization createOrganization(Organization organization)
```

**Обоснование:**
- Защита от неповторяющегося чтения при проверке уникальности имени
- Предотвращает создание дубликатов при одновременных запросах
- Более производительный, чем SERIALIZABLE
- Достаточен для предотвращения race condition при проверке существования

**UPDATE (обновление организации)** - **REPEATABLE_READ**:
```java
@Transactional(isolation = Isolation.REPEATABLE_READ)
public Organization updateOrganization(Organization organization)
```

**Обоснование:**
- Защита от lost update problem
- Гарантирует, что данные не изменятся между чтением и записью
- Предотвращает одновременное изменение одной организации несколькими пользователями
- При конфликте одна транзакция откатится и может быть повторена

**DELETE (удаление организации)** - **REPEATABLE_READ**:
```java
@Transactional(isolation = Isolation.REPEATABLE_READ)
public boolean deleteOrganization(Long id)
```

**Обоснование:**
- Предотвращает попытки удаления уже удаленной записи
- Гарантирует целостность при одновременном доступе
- Одна из конкурирующих транзакций получит ошибку

**READ (чтение данных)** - **READ_COMMITTED** (по умолчанию):
```java
@Transactional(readOnly = true)
public List<Organization> getAllOrganizations()
```

**Обоснование:**
- Операции чтения не требуют высокой изоляции
- READ_COMMITTED достаточно для предотвращения грязного чтения
- Обеспечивает лучшую производительность
- readOnly = true оптимизирует работу с БД

#### 3.2 Операция импорта

**IMPORT** - **SERIALIZABLE**:
```java
@Transactional(isolation = Isolation.SERIALIZABLE, rollbackFor = Exception.class)
public ImportHistory importOrganizations(...)
```

**Обоснование:**
- Множественные проверки уникальности требуют полной изоляции
- Предотвращает фантомное чтение при проверке существующих записей
- Гарантирует атомарность массовой операции
- Критична корректность при одновременном импорте

### 4. JMeter тестовые сценарии

Реализованы следующие сценарии для проверки поведения системы:

#### 4.1 Concurrent Create - Uniqueness Test
**Цель**: Проверка корректности соблюдения ограничений уникальности

**Конфигурация:**
- 5 одновременных потоков
- Каждый поток пытается создать организацию с уникальным именем

**Ожидаемый результат:**
- Все 5 организаций должны быть созданы успешно
- Имена должны быть уникальными благодаря использованию ${__threadNum}
- Нет конфликтов благодаря REPEATABLE_READ

#### 4.2 Concurrent Update - Same Record
**Цель**: Проверка поведения при одновременном обновлении одной записи

**Конфигурация:**
- 3 одновременных потока
- Все потоки пытаются обновить организацию с ID=1

**Ожидаемый результат:**
- Только одна транзакция завершится успешно
- Остальные получат ошибку из-за конфликта блокировок
- Данные остаются консистентными
- REPEATABLE_READ предотвращает lost update

#### 4.3 Concurrent Delete - Same Record
**Цель**: Проверка поведения при одновременном удалении одной записи

**Конфигурация:**
- 3 одновременных потока
- Все потоки пытаются удалить организацию с ID=2

**Ожидаемый результат:**
- Первый поток успешно удаляет запись
- Остальные получают ошибку (запись не найдена)
- Нет дублирования операций удаления

### 5. Результаты тестирования

#### 5.1 Тест уникальности имени организации

При одновременном создании организаций с одинаковым именем:
- ✅ Только одна транзакция успешно создает организацию
- ✅ Остальные получают ошибку "Организация с именем уже существует"
- ✅ В БД нет дубликатов

#### 5.2 Тест уникальности zipCode

При одновременном создании адресов с одинаковым zipCode:
- ✅ Только одна транзакция завершается успешно
- ✅ Остальные получают ошибку "Адрес с zipCode уже существует"
- ✅ Проверка работает на уровне приложения без ограничений БД

#### 5.3 Тест одновременного обновления

При одновременном обновлении одной организации:
- ✅ REPEATABLE_READ предотвращает потерю обновлений
- ✅ Одна транзакция откатывается с ошибкой сериализации
- ✅ Итоговое состояние консистентно

#### 5.4 Тест импорта

При одновременном импорте разных файлов:
- ✅ SERIALIZABLE гарантирует полную изоляцию
- ✅ Проверки уникальности работают корректно
- ✅ При ошибке в любом объекте откатывается весь импорт
- ✅ История сохраняется для всех операций

### 6. Выводы

#### 6.1 Выбор уровней изоляции

1. **SERIALIZABLE для импорта** - необходим из-за:
   - Множественных проверок существования записей
   - Критичности атомарности массовых операций
   - Необходимости предотвращения фантомного чтения

2. **REPEATABLE_READ для CUD операций** - оптимален для:
   - Предотвращения lost update при изменении данных
   - Защиты от race condition при проверке уникальности
   - Баланса между производительностью и изоляцией

3. **READ_COMMITTED для чтения** - достаточен для:
   - Операций, не изменяющих данные
   - Обеспечения максимальной производительности
   - Предотвращения только грязного чтения

#### 6.2 Преимущества реализации

- ✅ Транзакционная целостность гарантирована на всех уровнях
- ✅ Проверки уникальности работают без ограничений БД
- ✅ История операций позволяет отслеживать импорт
- ✅ Система корректно работает при одновременном доступе
- ✅ Выбранные уровни изоляции обеспечивают баланс корректности и производительности

### 7. Запуск JMeter тестов

```bash
# Установка JMeter (если не установлен)
# Скачать с https://jmeter.apache.org/download_jmeter.cgi

# Запуск тестов
jmeter -n -t jmeter/organization-load-test.jmx -l results.jtl -e -o report

# Или через GUI для отладки
jmeter -t jmeter/organization-load-test.jmx
```

### 8. Использование импорта

1. Откройте браузер и перейдите на `http://localhost:8080/lab1/import`
2. Введите имя пользователя
3. Выберите JSON файл (пример: `import-example.json`)
4. Нажмите "Загрузить и импортировать"
5. Просмотрите результат в истории импорта

### 9. Структура проекта

```
lab2/
├── src/main/java/org/itmo/lab1/
│   ├── model/
│   │   ├── ImportHistory.java          # История импорта
│   │   └── ...
│   ├── dto/
│   │   └── OrganizationImportDto.java  # DTO для импорта
│   ├── repository/jpa/
│   │   ├── ImportHistoryRepositoryJpa.java
│   │   ├── OrganizationRepositoryJpa.java  # + методы проверки уникальности
│   │   ├── AddressRepositoryJpa.java       # + методы проверки уникальности
│   │   └── ...
│   ├── service/
│   │   ├── ImportService.java          # Транзакционный импорт
│   │   ├── OrganizationService.java    # + уровни изоляции
│   │   └── ...
│   └── controller/
│       ├── ImportController.java       # Контроллер импорта
│       └── ...
├── src/main/webapp/WEB-INF/views/
│   └── import.jsp                      # Интерфейс импорта
├── jmeter/
│   └── organization-load-test.jmx      # JMeter тесты
├── import-example.json                  # Пример файла импорта
└── README.md                           # Эта документация
```
